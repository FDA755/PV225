//IntroductionToOOP
#include<iostream>
using namespace std;
#define delimiter "\n----------------------------------------------------------\n"

//КЛАСС - это тип данных!!!
//СТРУКТУРА - это тип данных!!!

class Point  //Создавая труктуру или класс мы создаем нвоый тип данных
{//Классы и структуры еще называют пользовательскими (составными) типами данных.
	double x;
	double y;
public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}

	//      Constructors:
	/*Point()   //Конструктор по умолчанию
	{
		x = y = 0;
		//RAII - Resource Aquilisation - Is Initialisation (Выделение ресурсов - значит инициализация)
		cout << "DefaultConstructor:" << this << endl;
	}
	Point(double x)    //Конструктор с одним параметром
	{
		this->x = x;
		this->y = 0;
		cout << "1ArgConstructor:" << this << endl;
	}*/
	Point(double x =0, double y=0)   //Конструктор с параметрами
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t" << this << endl;
	}
	Point(const Point& other)     //Конструктор копирования
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:" << this << endl;
	}
	~Point()
	{
		cout << "Destructor:\t" << this << endl;
	}
	//		Operators:
	Point& operator =(const Point& other)    //Оператор присвоения    //Дописав & к Oint Мы обращаемся по ссылке, что не заставляет компилятор вызывать Конструкотры копирования
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyAssignment:\t" << this << endl;   
		return *this;
	}
	Point& operator++() //Перегружаем оператор ++ внутри класса, так как они изменяет тоьлко свой операнд. - Это префиксный ++
	{
		x++;
		y++;
		return *this;
	}
	Point operator++(int) //Перегружаем оператор ++ внутри класса, так как они изменяет тоьлко свой операнд. - Это постфиксный ++
	{
		Point old = *this;
		x++;
		y++;
		return old;
	}
	Point& operator()(double x, double y)
	{
		set_x(x);
		set_y(y);
		return *this;
	}

	//      Method
	double distance(const Point& other)const    //& -передача парметров по ссылке , & - оператор взятия адреса. Чтобы нельзя было измениьб(защитить), нужно передавать по константной ссылке 'const Point& other'
	{
		//other.x *= 125;  //При передаче параметров по ссылке, значение может изменяться
		double x_distance = this->x - other.x;
		double y_distance = this->y - other.y;
		double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
		return distance;
	}
	void print()const
	{
		cout << "X = " << x << "\tY = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	double x_distance = A.get_x() - B.get_x();
	double y_distance = A.get_y() - B.get_y();
	double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
	return distance;
}

Point operator+(const Point& left, const Point& right) // Перегружаем оператор '+'
{
	Point res;
	res.set_x(left.get_x() + right.get_x());
	res.set_y(left.get_y() + right.get_y());
	return res;
}

//      Comparison Operators
bool operator==(const Point& left, const Point& right)
{
	/*if (left.get_x() == right.get_x() && left.get_y() == right.get_y())
		return true;
	else
		return false; */  
	return left.get_x() == right.get_x() && left.get_y() == right.get_y();    //Условие выше True/False можно записать короче, т.к тоже самое выводит само условие IF
}
bool operator!=(const Point& left, const Point& right)
{
	return !(left == right);
}

std::ostream& operator<<(std::ostream& os, const Point& obj)   //Тут 'cout' будет прилетать в 'os', а объект 'A' в 'obj'. Оператор '<<' мы не модем перегрузить в классе Point, так как он относится к классу 'ostream'
{																//Потоки всегда принимаются и возвращаются только по ссылке 'std::ostream&'
	return os << "X = " << obj.get_x() << "\tY = " << obj.get_y();
}
std::istream& operator>>(std::istream& is, Point& obj)
{
	double x, y;
	is >> x;
	is >> y;
	obj(x, y);
	return is;
}

//#define STRUCT_POINT
//#define DISTANCE_CHECK
//#define CONSTRUCTORS_CHECK
//#define ASSIGNMENT_CHECK_1
//#define ASSIGNMENT_CHECK_2
void main()
{
	setlocale(LC_ALL, "");
	cout << "Hello OOP" << endl;
#ifdef STRUCT_POINT
	int a;    //Объявление 'a' типа 'int'
	Point A;  //Объявоение объекта 'A'типа 'Point'
			  //Объявление объекта A структуры Pooint
	          //Создание экземпляра A структуры Pooint
	//Объекты часта называют экземплярами класса или структуры
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;

	Point* pA = &A;
	cout << pA->x << "\t" << pA->y << endl;
#endif //STRUCT_POINT
#ifdef DISTANCE_CHECK
	Point A;
	A.set_x(2);
	A.set_y(3);
	Point B;
	B.set_x(7);
	B.set_y(8);
	cout << A.get_x() << "\t" << A.get_y() << endl; cout << delimiter << endl;
	cout << "Расстояние от точки А до точки В: " << A.distance(B) << endl; cout << delimiter << endl;
	cout << "Расстояние от точки B до точки A: " << B.distance(A) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками B до точки A: " << distance(A,B) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками А до точки A: " << distance(B,A) << endl; cout << delimiter << endl;
#endif // DISTANCE_CHECK
#ifdef  CONSTRUCTORS_CHECK
	Point A; //Default constructor
	//cout << A.get_x() << "\t" << A.get_y() << endl;
	A.print();

	Point B(2, 3);
	B.print();

	Point C = 4; //Single-Argument constructor
	C.print();

	Point D = C; // Copy constructor
	D.print();
#endif // CONSTRUCTORS_CHECK
#ifdef ASSIGNMENT_CHECK_1
	//CopyAssignment
	Point A(2, 3);
	A.print();
	Point B = A;	//CopyConstructor
	B.print();
	Point C;		//DefaultConstructor
	C = B;			//Assignment operator (CopyAssignment)
	C.print();
#endif // ASSIGNMENT_CHECK_1
#ifdef ASSIGNMENT_CHECK_2
	int a, b, c;
	a = b = c = 0;
	Point A, B, C;
	cout << delimiter << endl;
	A = B = C = Point(2, 3);
	//Point(2,3) - явный вызов конструктора, и этот конструктор создает временный безымянный объект.
	//Временные безымянные объекты существуют в пределах одного выражения.
	cout << delimiter << endl;
	/*cout << "Begin" << endl;
	Point(2, 3);
	cout << "End" << endl;*/

#endif // ASSIGNMENT_CHECK_2

	/*int a = 2;
	int b = 3;
	int c = a + b;

	Point A(2, 3);
	Point B(2, 3);
	Point C = A + B;
	C.print();
	++C;
	C.print();
	C++;
	C.print();

	cout << (A == A) << endl;
	cout << (A != A) << endl;*/

	Point A(2, 3);
	A.print();
	/*A.set_x(12);
	A.set_y(13);*/
	A(3, 4);
	A.print();
	cout << A <<endl;
	cout << "Type Point coordinats: "; cin >> A;
	cout <<A << endl;
}

/* 

*/


/* OOP - Object-Oriented Programming - это подход,при котором программа состоит из объектов.
   OOD - Object-Oriented Design (объектно-ориентированное проектирование).

Объект - это некая сущность, которая существует в пространстве и времени.
OOP позволяет спроецировать объекты объективной и субъективной реальности в виртуальную.
Множество объектов с одинаковым набором характеристик , состояний и поведений называют клонами.

Класс - это синтасическая конструкция, позволяющая описывать объекты.
Кроме классов, объекты так же можно описывать при помощи структур.
members:
1. Переменные члены класса - описывают характеристики и состояния объектов.
2. Методы - определяют поведение объектов и взаимодействие их с другими объектами.
   Метод - это функция внутри класса.
   Метод может быть вызван только для какого-то объекта.


. -  Для обращения к полям объекта (Point Operator) - используется для доступа к полям объекта по имени объекта
-> - оператор косвенного доступа (Arrow operator) - используется для доступа к полям объекта по адресу объекта

  Концепции ООП 
  ООП базаруется на трех основных понятиях
  1. Инкапсуляция (incspsulation) - сокрытие определенных частей класса от внешнего мира. Инкапсуляция реализуется модификаторами доступа и get/set методами.
  2. Настледование (Inheritance) - 
  3. Полимрфизм (Polymorphism)

  В языке С++ существует только 3 модификатор адоступа:
  Privite - приватные поля или закрытые поля, доступны только внетри класса. Переменные члены класса обязательно должны быть приватными,
  это защищает их от случайной перезаписи.
  Public - Открытые поля, доступные из любого места программы. В pablic секции обычно размещают методы.
  Protect - Защищенные поля, доступны в нутри нашего класса и его дочерних классов. Этот модификатор доступа используется только при настледовании.

	Единственным отлицичем между классом и структурой является, то что в структуре все поля по умолчанию открыты, а в классе все поля по умолчанию закрыты.
	get/set методы - обеспечивают доступ из вне к закрытым переменным в классе.
	get - позволяют получить значение переменной (открывают доступ на чтение к пременным членам класса). 
	get методы обязательно должны быть константными. Константным называется метод, который не изменяет объект, для которого вызывается.
Для константного объекта могут быть вызваны только константные методы.
this -> - это указатель на объект для которого вызывается метод.
	set - позволяет задать значение переменной в классе (открывают доступ к переменным членам класса на запись).Кроме того,set методы обеспечивают фильтрацию данных.

		Конструкторы.
		Особые методы в классе.
	В любом классе обязательно должны быть такие методы как конструктор, деструктор и оператор присваевания.
	1. Constructor - метод, который создает объект, а именно, выделяет память под объект и инициализирует его поля при создании объекта.
	2. ~Destructor - это метод, который уничтожает объект по истечении его времени жизни. Время жизни объекта истекает, когда мы выходим за пределы области видимости, в которой объявлен этот объект.
	Например при завершении функции в которой объявлен объект. Если счетчик цикла FOR считать объектом, то по завершении всех итераций FOR ,то для него будет вызван деструктор.
	3. Assignment operator - 

19.01.2023 (movie 4) Конструктор по умолчанию - конструктор, который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор, каждый параметр которого имеет значение по умолчанию.
Конструктор по умолчанию выделяет память под ибъект и инициализирует все его поля значениями по умолчанию. Конструктор по умолчанию всякий раз не явно вызывается ,когда мы просто создаем объект и не знаем каким он будет.
Например Point A; (Default constructor). Т.е если в классе нет ни одного конструктора, то компилятор сам добывит туда конструктор по умолчанию. Потому, что без конструктора не возможно созать объект. Такой не явный Конструктор по умолчанию просто
выделяет память под объект и инициализирует его поля значеними по умолчанию.
	Если мы хотим определять каким будет объект при его создании, то нужен Конструктор с параметрами.
	Особое место в параметризованных конструкторах занимает конструктор с обдим параметром- Point C = 4; //Single-Argument constructor
	Конструктор с параметрами по умолчанию может быть универсальным и вызываться во всех ситуациях для создания объекта. Но иногда, лучше перегрузить конструктор, чем использовать универсальный конструктор.
  
 23.01.2023 (movie 6) Конструктор копирования -конструктор, который копирует объект, а именно создаваемый объект делает точной копией копируемого объекта.
 Конструктор копирования всегда принимает константную ссылку на объект нашего класса. Он всякий раз не явно вызывается, когда нужно копировать объект. 
Point D = С; // Copy constructor
 Также, как и конструктор по умолчанию, Контруктор копирования может быть не явным. То есть, если мы его не написали, компилятор сам его добавит. 
 Конструктор копирования особенно важен при использовании в классе динамической памяти. Он должен выполнять так называемое DeepCopy (побитовое копирование, побайтовое копирование, поэлементное копирование).
Не явный конструктор копирования не может этого сделать и выполняет ShallowCopy (поверхностное копирование), т.е копирование адреса памяти вместо содержимого памяти.
	Если возникает скопировать сузествуюзий объект после его создания, а именно , существующий объект сделать точной копией другого сузествуюзего объекта, для этих целей мы не сможем вызвать конструктор копирования. 
Потому, что люой конструктор может быть вызван ,только для создания объета. Конструктор не возможно вызвать после созданя объекта. 
Ждя того, чтобы скопирвоать сузествуюзий объект, вызывается опироватор присваивания, или же CopyAssignment. Оператор присваивания делает тоже самое ,что и конструктор копирования, но после создания объекта (для существуюзего объекта).
Так же как и конструктор копирования оператор присваивания принимает константную ссылку на объект и выполняет теже действия,что и конструктор копировани, но уже для сузествующего объекта.
Так же как и конструктор копирвоания оператор присваивания критически важен ,если в классе используется динамическая память. И он также может быть не явным.
Так же как и конструктор копирвоания оператор присваивания должен выполнять DeepCopy.

25.01.2023 (movie 7) Мы много говорили о том, как мождно передать параметры в функцию по значению, по указателю и по ссылке. но не говорили как фенкция может возвразать значение по значению, по указателю, по ссылке.
  При возврате по значени, возвращаемое значение копируется на место вызова. А при возврате значения по указателю, либо по ссылке на место вызова копируется адресс возвращаемого значения.
  Если возвращаемое значение является объектом, то для его копирования вызывается конструктор копирования. Для того, чтобы скопировать адресс объекта, конструктор копирования не нужен.
  При возврате объекта по значению, создается еще один оюъект, что приводит к дополнительным затратам ресурсов.
  И возвращая объект по адресу можно съэкономить ресурсы, но тут нужно быть очень осторожным, поскольку если мы вернем ссылку или указатель на локальный объект, то он удалится по завершении функции и на месте вызова мы увидим мусор.
  ----выражение, это синтаксическая конструкция, которая состорит и опараторов и операндов. Выражение и область видимости ,это одно и тоже. Область видимости -{} может состоять из нескольких выражений (), но и выраженеи уже является область. видимости {();(),()}.
    Перегрузка операторов.
Перегрузка операторов нужна для более удобной работы с объектами, чтобы с объектами можно было выполнять такие же действиями, как над обычными переменными.
Правила перегрузки операторов:
1. Перегрузить можно только существующие операторы, НЕВОЗМОЖНО создавать новые операторы.
	Например:
	+  - перегружается;  ++ - перегружается;  *  - перегружается;  ** - не перегружается;
2. Не все существующие операторы можно перегрузить, не перезагружаются:
	?: - Conditional ternary
	:: - Scope operator (Оператор разрешения видимости)
	.  - Point operator (Оператор прямого доступа)
	.* - Point to member selection
	#  - Processor directive
	## - Preprocessor concatination
3. Переопределить поведение операторов над встроенными типами не возможно. Например: НЕВОЗМОЖНО заставить оператор + выполнять другие действия над типом данных Int кроме сложения.
4. Перегруженные операторы сохраняют приоритет.
	Перегруженные операторы - это самые обычные функции, имя которых состоит из ключевого слова 'operator' и знака существующего оператора ' = '   -  Point& operator=();Эти функции можно описать как в классе, так и за классом.
Если оператор перегружен в классе, то он является методом, а значит может быть вызван только для какого-то объекта.
Если оператор перегружен за классом, то он является самой обычной функцией, а значит может быть вызван сам по себе.
Если унарный оператор перегружен внутри класса, то он никогда не принимает нкаких параметров, а единственным его операндом является объект, для которого он вызывается. И к этомк объекту можно образаться через 'this'.
Если унарный оператор перегружен за классом, то он принимает один и только один параметр - операнд.
Если бинарный оператор пепергружен внутри класса, то он в обязательном порядке принимает один и только один параметр - свой операнд справа, а его операндом слева является объект ,для которого он вызывается.
Если бинарный оператор перегружен за классом, то он в обязательном порядке принимает два параметра - свои операнды.
	При перегрузке операторов всегда следует учитывать, что некоторое операторы изменяют свои операнды, а некоторые нет. Те операторы, которые изменяют свои операнды, удобнее перегружать внутри класса, чтобы иметь доступ к переменным членам класса.
Операторы, которые изменяют свои операнды, удобнее изменять за классом.
Ctr+K+S to define
	
	26.01.2023 Перегрузка операторов сравнения.
    Операторы сравнения всегда возвращают значения типа bool. Их лучше перегружать за класом , потому-что они не изменяют свои операнды.
cout - является объектом класса 'ostream' 'os'
cin - является объектом класса 'istream'  'is'
  */