//IntroductionToOOP
#include<iostream>
using namespace std;
#define delimiter "\n----------------------------------------------------------\n"

//КЛАСС - это тип данных!!!
//СТРУКТУРА - это тип данных!!!

class Point  //Создавая труктуру или класс мы создаем нвоый тип данных
{//Классы и структуры еще называют пользовательскими (составными) типами данных.
	double x;
	double y;
public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}

	//      Constructors:
	/*Point()   //Конструктор по умолчанию
	{
		x = y = 0;
		//RAII - Resource Aquilisation - Is Initialisation (Выделение ресурсов - значит инициализация)
		cout << "DefaultConstructor:" << this << endl;
	}
	Point(double x)    //Конструктор с одним параметром
	{
		this->x = x;
		this->y = 0;
		cout << "1ArgConstructor:" << this << endl;
	}*/
	Point(double x =0, double y=0)   //Конструктор с параметрами
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t" << this << endl;
	}
	Point(const Point& other)     //Конструктор копирования
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:" << this << endl;
	}
	~Point()
	{
		cout << "Destructor:\t" << this << endl;
	}
	//		Operators:
	Point operator =(const Point& other)    //Оператор присвоения
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyAssignment:\t" << this << endl;   
		return *this;
	}
	//      Method
	double distance(const Point& other)const    //& -передача парметров по ссылке , & - оператор взятия адреса. Чтобы нельзя было измениьб(защитить), нужно передавать по константной ссылке 'const Point& other'
	{
		//other.x *= 125;  //При передаче параметров по ссылке, значение может изменяться
		double x_distance = this->x - other.x;
		double y_distance = this->y - other.y;
		double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
		return distance;
	}
	void print()const
	{
		cout << "X = " << x << "\tY = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	double x_distance = A.get_x() - B.get_x();
	double y_distance = A.get_y() - B.get_y();
	double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
	return distance;
}

//#define STRUCT_POINT
//#define DISTANCE_CHECK
//#define CONSTRUCTORS_CHECK
//#define ASSIGNMENT_CHECK_1
#define ASSIGNMENT_CHECK_2
void main()
{
	setlocale(LC_ALL, "");
	cout << "Hello OOP" << endl;
#ifdef STRUCT_POINT
	int a;    //Объявление 'a' типа 'int'
	Point A;  //Объявоение объекта 'A'типа 'Point'
			  //Объявление объекта A структуры Pooint
	          //Создание экземпляра A структуры Pooint
	//Объекты часта называют экземплярами класса или структуры
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;

	Point* pA = &A;
	cout << pA->x << "\t" << pA->y << endl;
#endif //STRUCT_POINT
#ifdef DISTANCE_CHECK
	Point A;
	A.set_x(2);
	A.set_y(3);
	Point B;
	B.set_x(7);
	B.set_y(8);
	cout << A.get_x() << "\t" << A.get_y() << endl; cout << delimiter << endl;
	cout << "Расстояние от точки А до точки В: " << A.distance(B) << endl; cout << delimiter << endl;
	cout << "Расстояние от точки B до точки A: " << B.distance(A) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками B до точки A: " << distance(A,B) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками А до точки A: " << distance(B,A) << endl; cout << delimiter << endl;
#endif // DISTANCE_CHECK
#ifdef  CONSTRUCTORS_CHECK
	Point A; //Default constructor
	//cout << A.get_x() << "\t" << A.get_y() << endl;
	A.print();

	Point B(2, 3);
	B.print();

	Point C = 4; //Single-Argument constructor
	C.print();

	Point D = C; // Copy constructor
	D.print();
#endif // CONSTRUCTORS_CHECK
#ifdef ASSIGNMENT_CHECK_1
	//CopyAssignment
	Point A(2, 3);
	A.print();
	Point B = A;	//CopyConstructor
	B.print();
	Point C;		//DefaultConstructor
	C = B;			//Assignment operator (CopyAssignment)
	C.print();
#endif // ASSIGNMENT_CHECK_1
#ifdef ASSIGNMENT_CHECK_2
	int a, b, c;
	a = b = c = 0;
	Point A, B, C;
	A = B = C = Point(2, 3);

#endif // ASSIGNMENT_CHECK_2
}






/* OOP - Object-Oriented Programming - это подход,при котором программа состоит из объектов.
   OOD - Object-Oriented Design (объектно-ориентированное проектирование).

Объект - это некая сущность, которая существует в пространстве и времени.
OOP позволяет спроецировать объекты объективной и субъективной реальности в виртуальную.
Множество объектов с одинаковым набором характеристик , состояний и поведений называют клонами.

Класс - это синтасическая конструкция, позволяющая описывать объекты.
Кроме классов, объекты так же можно описывать при помощи структур.
members:
1. Переменные члены класса - описывают характеристики и состояния объектов.
2. Методы - определяют поведение объектов и взаимодействие их с другими объектами.
   Метод - это функция внутри класса.
   Метод может быть вызван только для какого-то объекта.


. -  Для обращения к полям объекта (Point Operator) - используется для доступа к полям объекта по имени объекта
-> - оператор косвенного доступа (Arrow operator) - используется для доступа к полям объекта по адресу объекта

  Концепции ООП 
  ООП базаруется на трех основных понятиях
  1. Инкапсуляция (incspsulation) - сокрытие определенных частей класса от внешнего мира. Инкапсуляция реализуется модификаторами доступа и get/set методами.
  2. Настледование (Inheritance) - 
  3. Полимрфизм (Polymorphism)

  В языке С++ существует только 3 модификатор адоступа:
  Privite - приватные поля или закрытые поля, доступны только внетри класса. Переменные члены класса обязательно должны быть приватными,
  это защищает их от случайной перезаписи.
  Public - Открытые поля, доступные из любого места программы. В pablic секции обычно размещают методы.
  Protect - Защищенные поля, доступны в нутри нашего класса и его дочерних классов. Этот модификатор доступа используется только при настледовании.

	Единственным отлицичем между классом и структурой является, то что в структуре все поля по умолчанию открыты, а в классе все поля по умолчанию закрыты.
	get/set методы - обеспечивают доступ из вне к закрытым переменным в классе.
	get - позволяют получить значение переменной (открывают доступ на чтение к пременным членам класса). 
	get методы обязательно должны быть константными. Константным называется метод, который не изменяет объект, для которого вызывается.
Для константного объекта могут быть вызваны только константные методы.
this -> - это указатель на объект для которого вызывается метод.
	set - позволяет задать значение переменной в классе (открывают доступ к переменным членам класса на запись).Кроме того,set методы обеспечивают фильтрацию данных.

		Конструкторы.
		Особые методы в классе.
	В любом классе обязательно должны быть такие методы как конструктор, деструктор и оператор присваевания.
	1. Constructor - метод, который создает объект, а именно, выделяет память под объект и инициализирует его поля при создании объекта.
	2. ~Destructor - это метод, который уничтожает объект по истечении его времени жизни. Время жизни объекта истекает, когда мы выходим за пределы области видимости, в которой объявлен этот объект.
	Например при завершении функции в которой объявлен объект. Если счетчик цикла FOR считать объектом, то по завершении всех итераций FOR ,то для него будет вызван деструктор.
	3. Assignment operator - 

19.01.2023 (movie 4) Конструктор по умолчанию - конструктор, который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор, каждый параметр которого имеет значение по умолчанию.
Конструктор по умолчанию выделяет память под ибъект и инициализирует все его поля значениями по умолчанию. Конструктор по умолчанию всякий раз не явно вызывается ,когда мы просто создаем объект и не знаем каким он будет.
Например Point A; (Default constructor). Т.е если в классе нет ни одного конструктора, то компилятор сам добывит туда конструктор по умолчанию. Потому, что без конструктора не возможно созать объект. Такой не явный Конструктор по умолчанию просто
выделяет память под объект и инициализирует его поля значеними по умолчанию.
	Если мы хотим определять каким будет объект при его создании, то нужен Конструктор с параметрами.
	Особое место в параметризованных конструкторах занимает конструктор с обдим параметром- Point C = 4; //Single-Argument constructor
	Конструктор с параметрами по умолчанию может быть универсальным и вызываться во всех ситуациях для создания объекта. Но иногда, лучше перегрузить конструктор, чем использовать универсальный конструктор.
  
 23.01.2023 (movie 7) Конструктор копирования -конструктор, который копирует объект, а именно создаваемый объект делает точной копией копируемого объекта.
 Конструктор копирования всегда принимает константную ссылку на объект нашего класса. Он всякий раз не явно вызывается, когда нужно копировать объект. 
Point D = С; // Copy constructor
 Также, как и конструктор по умолчанию, Контруктор копирования может быть не явным. То есть, если мы его не написали, компилятор сам его добавит. 
 Конструктор копирования особенно важен при использовании в классе динамической памяти. Он должен выполнять так называемое DeepCopy (побитовое копирование, побайтовое копирование, поэлементное копирование).
Не явный конструктор копирования не может этого сделать и выполняет ShallowCopy (поверхностное копирование), т.е копирование адреса памяти вместо содержимого памяти.
	Если возникает скопировать сузествуюзий объект после его создания, а именно , существующий объект сделать точной копией другого сузествуюзего объекта, для этих целей мы не сможем вызвать конструктор копирования. 
Потому, что люой конструктор может быть вызван ,только для создания объета. Конструктор не возможно вызвать после созданя объекта. 
Ждя того, чтобы скопирвоать сузествуюзий объект, вызывается опироватор присваивания, или же CopyAssignment. Оператор присваивания делает тоже самое ,что и конструктор копирования, но после создания объекта (для существуюзего объекта).
Так же как и конструктор копирования оператор присваивания принимает константную ссылку на объект и выполняет теже действия,что и конструктор копировани, но уже для сузествующего объекта.
Так же как и конструктор копирвоания оператор присваивания критически важен ,если в классе используется динамическая память. И он также может быть не явным.
Так же как и конструктор копирвоания оператор присваивания должен выполнять DeepCopy.
  */