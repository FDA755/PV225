//IntroductionToOOP
#include<iostream>
using namespace std;
#define delimiter "\n----------------------------------------------------------\n"

//КЛАСС - это тип данных!!!
//СТРУКТУРА - это тип данных!!!

class Point  //Создавая труктуру или класс мы создаем нвоый тип данных
{//Классы и структуры еще называют пользовательскими (составными) типами данных.
	double x;
	double y;
public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}

	//      Constructors:
	/*Point()   //Конструктор по умолчанию
	{
		x = y = 0;
		//RAII - Resource Aquilisation - Is Initialisation (Выделение ресурсов - значит инициализация)
		cout << "DefaultConstructor:" << this << endl;
	}
	Point(double x)    //Конструктор с одним параметром
	{
		this->x = x;
		this->y = 0;
		cout << "1ArgConstructor:" << this << endl;
	}*/
	Point(double x =0, double y=0)   //Конструктор с параметрами
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t" << this << endl;
	}
	Point(const Point& other)     //Конструктор копирования
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:" << this << endl;
	}
	~Point()
	{
		cout << "Destructor:\t" << this << endl;
	}
	//		Operators:
	Point& operator =(const Point& other)    //Оператор присвоения    //Дописав & к Oint Мы обращаемся по ссылке, что не заставляет компилятор вызывать Конструкотры копирования
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyAssignment:\t" << this << endl;   
		return *this;
	}
	Point& operator++() //Перегружаем оператор ++ внутри класса, так как они изменяет тоьлко свой операнд. - Это префиксный ++
	{
		x++;
		y++;
		return *this;
	}
	Point operator++(int) //Перегружаем оператор ++ внутри класса, так как они изменяет тоьлко свой операнд. - Это постфиксный ++
	{
		Point old = *this;
		x++;
		y++;
		return old;
	}
	Point& operator()(double x, double y)
	{
		set_x(x);
		set_y(y);
		return *this;
	}

	//      Method
	double distance(const Point& other)const    //& -передача парметров по ссылке , & - оператор взятия адреса. Чтобы нельзя было измениьб(защитить), нужно передавать по константной ссылке 'const Point& other'
	{
		//other.x *= 125;  //При передаче параметров по ссылке, значение может изменяться
		double x_distance = this->x - other.x;
		double y_distance = this->y - other.y;
		double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
		return distance;
	}
	void print()const
	{
		cout << "X = " << x << "\tY = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	double x_distance = A.get_x() - B.get_x();
	double y_distance = A.get_y() - B.get_y();
	double distance = sqrt(x_distance * x_distance + y_distance * y_distance);
	return distance;
}

Point operator+(const Point& left, const Point& right) // Перегружаем оператор '+'
{
	Point res;
	res.set_x(left.get_x() + right.get_x());
	res.set_y(left.get_y() + right.get_y());
	return res;
}

//      Comparison Operators
bool operator==(const Point& left, const Point& right)
{
	/*if (left.get_x() == right.get_x() && left.get_y() == right.get_y())
		return true;
	else
		return false; */  
	return left.get_x() == right.get_x() && left.get_y() == right.get_y();    //Условие выше True/False можно записать короче, т.к тоже самое выводит само условие IF
}
bool operator!=(const Point& left, const Point& right)
{
	return !(left == right);
}

std::ostream& operator<<(std::ostream& os, const Point& obj)   //Тут 'cout' будет прилетать в 'os', а объект 'A' в 'obj'. Оператор '<<' мы не модем перегрузить в классе Point, так как он относится к классу 'ostream'
{																//Потоки всегда принимаются и возвращаются только по ссылке 'std::ostream&'
	return os << "X = " << obj.get_x() << "\tY = " << obj.get_y();
}
std::istream& operator>>(std::istream& is, Point& obj)
{
	double x, y;
	is >> x;
	is >> y;
	obj(x, y);
	return is;
}

//#define STRUCT_POINT
//#define DISTANCE_CHECK
//#define CONSTRUCTORS_CHECK
//#define ASSIGNMENT_CHECK_1
//#define ASSIGNMENT_CHECK_2
void main()
{
	setlocale(LC_ALL, "");
	cout << "Hello OOP" << endl;
#ifdef STRUCT_POINT
	int a;    //Объявление 'a' типа 'int'
	Point A;  //Объявоение объекта 'A'типа 'Point'
			  //Объявление объекта A структуры Pooint
	          //Создание экземпляра A структуры Pooint
	//Объекты часта называют экземплярами класса или структуры
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;

	Point* pA = &A;
	cout << pA->x << "\t" << pA->y << endl;
#endif //STRUCT_POINT
#ifdef DISTANCE_CHECK
	Point A;
	A.set_x(2);
	A.set_y(3);
	Point B;
	B.set_x(7);
	B.set_y(8);
	cout << A.get_x() << "\t" << A.get_y() << endl; cout << delimiter << endl;
	cout << "Расстояние от точки А до точки В: " << A.distance(B) << endl; cout << delimiter << endl;
	cout << "Расстояние от точки B до точки A: " << B.distance(A) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками B до точки A: " << distance(A,B) << endl; cout << delimiter << endl;
	cout << "Расстояние между точками А до точки A: " << distance(B,A) << endl; cout << delimiter << endl;
#endif // DISTANCE_CHECK
#ifdef  CONSTRUCTORS_CHECK
	Point A; //Default constructor
	//cout << A.get_x() << "\t" << A.get_y() << endl;
	A.print();

	Point B(2, 3);
	B.print();

	Point C = 4; //Single-Argument constructor
	C.print();

	Point D = C; // Copy constructor
	D.print();
#endif // CONSTRUCTORS_CHECK
#ifdef ASSIGNMENT_CHECK_1
	//CopyAssignment
	Point A(2, 3);
	A.print();
	Point B = A;	//CopyConstructor
	B.print();
	Point C;		//DefaultConstructor
	C = B;			//Assignment operator (CopyAssignment)
	C.print();
#endif // ASSIGNMENT_CHECK_1
#ifdef ASSIGNMENT_CHECK_2
	int a, b, c;
	a = b = c = 0;
	Point A, B, C;
	cout << delimiter << endl;
	A = B = C = Point(2, 3);
	//Point(2,3) - явный вызов конструктора, и этот конструктор создает временный безымянный объект.
	//Временные безымянные объекты существуют в пределах одного выражения.
	cout << delimiter << endl;
	/*cout << "Begin" << endl;
	Point(2, 3);
	cout << "End" << endl;*/

#endif // ASSIGNMENT_CHECK_2

	/*int a = 2;
	int b = 3;
	int c = a + b;

	Point A(2, 3);
	Point B(2, 3);
	Point C = A + B;
	C.print();
	++C;
	C.print();
	C++;
	C.print();

	cout << (A == A) << endl;
	cout << (A != A) << endl;*/

	Point A(2, 3);
	A.print();
	/*A.set_x(12);
	A.set_y(13);*/
	A(3, 4);
	A.print();
	cout << A <<endl;
	cout << "Type Point coordinats: "; cin >> A;
	cout <<A << endl;
}

/* 
Ctr+K+S to define
Shift+F5 - выйти из режима отладки
Ctrl+Shift+U - перевод в верхний регистр
Ctrl+U - нижний регистр
*/


/* 12.19.2022 Динамическая память.
	Для того ,чтобы объявить динамический массив нужно объявить указатель, и выделить память при помощи оператора 'new'.
int* arr = new int[n]
Оператор new выделяет непрерывный блок памяти для N элементов нужного типа и возвращает адресс выделенной памяти.
	Обращение к элементам динамического массива.
Можно обращаться точно таке как и к эдементам статических массивов - через арифметику указателей и операторов разыменования или же через оператор индексирования
Динамический массив передается в функцию точно также как и статический массив.
Массив в функцию можно передать как обычный указатель. И не важно как синтаксически мы его передаем, через * или [] -в функциб скопируется указатель на массив.
Оператор new запрашивает память у операционной системы на временное пользование и эту память нужно вернуть после того, ка кона уже будет не нужна. Для того , что вернуть память операционной системе -
массив нужно удалить delete[] arr;. Оператор delete Освобождает память по заданному адресу и возвращает ее операционной системе. Если только выделять память через new и не освобождать через delete, то вскоре 
операционная память в системе закончитс, что приведет к аварийному завершению нашей программы. Операторов delete должно быть ровно сколько и операторов new. Ситуация при коротой память была выделена, но не очищена
называется утечкой памяти.
12.21.2022 Двемерные динамические массивы.
	Для того, чтобы объявить двумерный динамический массив нужно объявить указатель на указатель и сохранить в него адресс массива указателей. 
Каждый эдемент массива указателей будет хранить адресс одномерного динамического массива. Эти одномерные динамические масивы являются строками длвумерного динамического массива.
Для того ,чтобы передать двумерный динамический массив в фенкцию, достаточно , чтобы фенкция принимала указатель на указатель и размер массива.

   OOP - Object-Oriented Programming - это подход,при котором программа состоит из объектов.
   OOD - Object-Oriented Design (объектно-ориентированное проектирование).

Объект - это некая сущность, которая существует в пространстве и времени.
OOP позволяет спроецировать объекты объективной и субъективной реальности в виртуальную.
Множество объектов с одинаковым набором характеристик , состояний и поведений называют клонами.

Класс - это синтасическая конструкция, позволяющая описывать объекты.
Кроме классов, объекты так же можно описывать при помощи структур.
members:
1. Переменные члены класса - описывают характеристики и состояния объектов.
2. Методы - определяют поведение объектов и взаимодействие их с другими объектами.
   Метод - это функция внутри класса.
   Метод может быть вызван только для какого-то объекта.


. -  Для обращения к полям объекта (Point Operator) - используется для доступа к полям объекта по имени объекта
-> - оператор косвенного доступа (Arrow operator) - используется для доступа к полям объекта по адресу объекта

  Концепции ООП 
  ООП базаруется на трех основных понятиях
  1. Инкапсуляция (incspsulation) - сокрытие определенных частей класса от внешнего мира. Инкапсуляция реализуется модификаторами доступа и get/set методами.
  2. Настледование (Inheritance) - 
  3. Полимрфизм (Polymorphism)

  В языке С++ существует только 3 модификатор адоступа:
  Privite - приватные поля или закрытые поля, доступны только внетри класса. Переменные члены класса обязательно должны быть приватными,
  это защищает их от случайной перезаписи.
  Public - Открытые поля, доступные из любого места программы. В pablic секции обычно размещают методы.
  Protect - Защищенные поля, доступны в нутри нашего класса и его дочерних классов. Этот модификатор доступа используется только при настледовании.

	Единственным отлицичем между классом и структурой является, то что в структуре все поля по умолчанию открыты, а в классе все поля по умолчанию закрыты.
	get/set методы - обеспечивают доступ из вне к закрытым переменным в классе.
	get - позволяют получить значение переменной (открывают доступ на чтение к пременным членам класса). 
	get методы обязательно должны быть константными. Константным называется метод, который не изменяет объект, для которого вызывается.
Для константного объекта могут быть вызваны только константные методы.
this -> - это указатель на объект для которого вызывается метод.
	set - позволяет задать значение переменной в классе (открывают доступ к переменным членам класса на запись).Кроме того,set методы обеспечивают фильтрацию данных.

		Конструкторы.
		Особые методы в классе.
	В любом классе обязательно должны быть такие методы как конструктор, деструктор и оператор присваевания.
	1. Constructor - метод, который создает объект, а именно, выделяет память под объект и инициализирует его поля при создании объекта.
	2. ~Destructor - это метод, который уничтожает объект по истечении его времени жизни. Время жизни объекта истекает, когда мы выходим за пределы области видимости, в которой объявлен этот объект.
	Например при завершении функции в которой объявлен объект. Если счетчик цикла FOR считать объектом, то по завершении всех итераций FOR ,то для него будет вызван деструктор.
	3. Assignment operator - 

19.01.2023 (movie 4) Конструктор по умолчанию - конструктор, который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор, каждый параметр которого имеет значение по умолчанию.
Конструктор по умолчанию выделяет память под ибъект и инициализирует все его поля значениями по умолчанию. Конструктор по умолчанию всякий раз не явно вызывается ,когда мы просто создаем объект и не знаем каким он будет.
Например Point A; (Default constructor). Т.е если в классе нет ни одного конструктора, то компилятор сам добывит туда конструктор по умолчанию. Потому, что без конструктора не возможно созать объект. Такой не явный Конструктор по умолчанию просто
выделяет память под объект и инициализирует его поля значеними по умолчанию.
	Если мы хотим определять каким будет объект при его создании, то нужен Конструктор с параметрами.
	Особое место в параметризованных конструкторах занимает конструктор с обдим параметром- Point C = 4; //Single-Argument constructor
	Конструктор с параметрами по умолчанию может быть универсальным и вызываться во всех ситуациях для создания объекта. Но иногда, лучше перегрузить конструктор, чем использовать универсальный конструктор.
  
 23.01.2023 (movie 6) Конструктор копирования -конструктор, который копирует объект, а именно создаваемый объект делает точной копией копируемого объекта.
 Конструктор копирования всегда принимает константную ссылку на объект нашего класса. Он всякий раз не явно вызывается, когда нужно копировать объект. 
Point D = С; // Copy constructor
 Также, как и конструктор по умолчанию, Контруктор копирования может быть не явным. То есть, если мы его не написали, компилятор сам его добавит. 
 Конструктор копирования особенно важен при использовании в классе динамической памяти. Он должен выполнять так называемое DeepCopy (побитовое копирование, побайтовое копирование, поэлементное копирование).
Не явный конструктор копирования не может этого сделать и выполняет ShallowCopy (поверхностное копирование), т.е копирование адреса памяти вместо содержимого памяти.
	Если возникает скопировать сузествуюзий объект после его создания, а именно , существующий объект сделать точной копией другого сузествуюзего объекта, для этих целей мы не сможем вызвать конструктор копирования. 
Потому, что люой конструктор может быть вызван ,только для создания объета. Конструктор не возможно вызвать после созданя объекта. 
Для того, чтобы скопирвоать существуюзий объект, вызывается опироватор присваивания, или же CopyAssignment. Оператор присваивания делает тоже самое ,что и конструктор копирования, но после создания объекта (для существуюзего объекта).
Так же как и конструктор копирования оператор присваивания принимает константную ссылку на объект и выполняет теже действия,что и конструктор копировани, но уже для существующего объекта.
Так же как и конструктор копирвоания оператор присваивания критически важен ,если в классе используется динамическая память. И он также может быть не явным.
Так же как и конструктор копирвоания оператор присваивания должен выполнять DeepCopy.

25.01.2023 (movie 7) Мы много говорили о том, как мождно передать параметры в функцию по значению, по указателю и по ссылке. но не говорили как фенкция может возвразать значение по значению, по указателю, по ссылке.
  При возврате по значени, возвращаемое значение копируется на место вызова. А при возврате значения по указателю, либо по ссылке на место вызова копируется адресс возвращаемого значения.
  Если возвращаемое значение является объектом, то для его копирования вызывается конструктор копирования. Для того, чтобы скопировать адресс объекта, конструктор копирования не нужен.
  При возврате объекта по значению, создается еще один оюъект, что приводит к дополнительным затратам ресурсов.
  И возвращая объект по адресу можно съэкономить ресурсы, но тут нужно быть очень осторожным, поскольку если мы вернем ссылку или указатель на локальный объект, то он удалится по завершении функции и на месте вызова мы увидим мусор.
  ----выражение, это синтаксическая конструкция, которая состорит и опараторов и операндов. Выражение и область видимости ,это одно и тоже. Область видимости -{} может состоять из нескольких выражений (), но и выраженеи уже является область. видимости {();(),()}.
    Перегрузка операторов.
Перегрузка операторов нужна для более удобной работы с объектами, чтобы с объектами можно было выполнять такие же действиями, как над обычными переменными.
Правила перегрузки операторов:
1. Перегрузить можно только существующие операторы, НЕВОЗМОЖНО создавать новые операторы.
	Например:
	+  - перегружается;  ++ - перегружается;  *  - перегружается;  ** - не перегружается;
2. Не все существующие операторы можно перегрузить, не перезагружаются:
	?: - Conditional ternary
	:: - Scope operator (Оператор разрешения видимости)
	.  - Point operator (Оператор прямого доступа)
	.* - Point to member selection
	#  - Processor directive
	## - Preprocessor concatination
3. Переопределить поведение операторов над встроенными типами не возможно. Например: НЕВОЗМОЖНО заставить оператор + выполнять другие действия над типом данных Int кроме сложения.
4. Перегруженные операторы сохраняют приоритет.
	Перегруженные операторы - это самые обычные функции, имя которых состоит из ключевого слова 'operator' и знака существующего оператора ' = '   -  Point& operator=();Эти функции можно описать как в классе, так и за классом.
Если оператор перегружен в классе, то он является методом, а значит может быть вызван только для какого-то объекта.
Если оператор перегружен за классом, то он является самой обычной функцией, а значит может быть вызван сам по себе.
Если унарный оператор перегружен внутри класса, то он никогда не принимает нкаких параметров, а единственным его операндом является объект, для которого он вызывается. И к этомк объекту можно образаться через 'this'.
Если унарный оператор перегружен за классом, то он принимает один и только один параметр - операнд.
Если бинарный оператор пепергружен внутри класса, то он в обязательном порядке принимает один и только один параметр - свой операнд справа, а его операндом слева является объект ,для которого он вызывается.
Если бинарный оператор перегружен за классом, то он в обязательном порядке принимает два параметра - свои операнды.
	При перегрузке операторов всегда следует учитывать, что некоторое операторы изменяют свои операнды, а некоторые нет. Те операторы, которые изменяют свои операнды, удобнее перегружать внутри класса, чтобы иметь доступ к переменным членам класса.
Операторы, которые изменяют свои операнды, удобнее изменять за классом.
	
	26.01.2023 Перегрузка операторов сравнения.
    Операторы сравнения всегда возвращают значения типа bool. Их лучше перегружать за класом , потому-что они не изменяют свои операнды.
cout - является объектом класса 'ostream' 'os'
cin - является объектом класса 'istream'  'is'

02.02.2023 (movie 12) Преобразование типов.
	Существует явные и неявные преобразования типов.
Явные преобразования выполняет программист, а не явные - компилятор. 
Для того ,чтобы явно преобразовать значение в другой тип данных, необходимо желаемый тип ланных написать в круглых скобках перед значением.
Или значение в круглых скобках после желаемого типа данных.  
(type)value  C-like notation (С-подобная форма записи)
type(value)  Functional notation (Функциональная форма записи)

Не явные преобразования типов выполняет компилятор, а именно операторы.
Все операторы C++ пытаются привести все значения в выражении к наибольшему типу данных для того, чтобы избедать потери данных и вернуть максимаотно точный результат. Кроме присваивания=.
cout << 7/2 <<endl; выведет int 3 / cout << 7./2 <<endl; выведет double 3.5
Операторы присваивания всегда значение справа приводят к типу слева, если типы преобразуются. И не важно, будет потеря данных или нет.
Как явные,так и не явные преобразованияюывают от меньшего к большему либо от большего к меньшему. причем последнее может привести к потере данных. При этом компилятор оюычно выдает предупреждение.
С4244 -conversion from 'type 1' to 'type 2' ,possible loss of data.
	int a = 2;			//No conversions
	double b = 3;		//Conversion from less to more
	int c = b;			//Conversion from more to lesswith no data loss
	int d = 4.5;		//Conversion from more to less with data loss


	Преобразование типов в ООП.
	В ООП сузествует два направления преобразования типов:
1. Преобразование других типов в нащ.
2. Преобразование из нашего типа в другие.
Для преобразование других типов в объекты нашего класса, в классе должны быть конструктор с одним параметром и оператор присваивания. Причем второй без первого не работает.
	Fraction A = 5;   //COnversion from other to class
	Конструктору с одним параметром применимо слово "Явный" - Explicit. Ключевое слово 'Explicit' запрещает не явное преобразование типов, и оставляет возможность лишь явно преобразовывать типы.
	Для того, чтобы объекты нашего класса преобразвывать в другие типы данных в классе должны быть соответствуюзие операторы преобразования.
	Операторы преобразования (Type-cast operators),это обычные методы, имя которых состоит из ключевого слова operator и спецификатора сузествующего типа
	operatot type()const
	{
	conversion algoritm;
	return...;
	}
	Операторы преобразования могут быть перегружены только внутри класса.
	Оператор ыпреобразования в обязательном порядке возвращают значения, хотя перед ними никогда не пишется тип возвращаемого значения.
	Поскольку он является частью имени оператора.
	К операторам преобразования типов также применимо ключевое слово eplicit, которое также запрещает не явные преобразования.

	//https://cplusplus.com/reference/cstring/strtok/?kw=strtok
	//https://cplusplus.com/reference/cstdlib/atoi/?kw=atoi
	number[n++] = atoi(pch);  //atoi - ASCII-string to integer преобразует строку в число, если строка является числом, т.е содержит цифры.
	#define _CRT_SECURE_NO_WARNINGS    //Если вылетает ошибка это, то так ее убираем, студия считает, что ыводится устаревший, не безопасный код
	is >> buffer;    -->     is.getline(buffer, SIZE);   //изменили, чтобы вводить строку с пробелом getline();

		Использование динамической памяти в классе.
		Если в классе есть хотябы один указатель, то скорее всего он указывает на область динамической памяти. И если это так,
	то в конструкторах удет использоваться оператор 'new'.
	Если в конструкторах используется оператор 'new', то в классе обязательно должен быть диструктор с оператором 'delet'.
	Кроме того в таком классе обязательно должны быть методы копирования (конструктор копирования и оператор присваивания).Эти методы выполняют побитовое копирование или же DeepCopy.
	А именно ,выделяют память при помощи оператора new и копируют всё содержимое в создаваемый объект. Не явные же конструкттор копирования и оператор присваивания выполняют ShalloCopy.
	Т.е просто копируют адресс памяти из одного объекта в другой, что приводит к тому, что появляется два и более объектов, влядеющих одной и тойже область динамической памяти.
	Что в свою очередь приводит к ошибкам на этапе выполения.

	Константная ссылка на объект - const Type& - это указатель на адрес объекта (0х500)
	https://cplusplus.com/doc/tutorial/classes2/
	https://www.youtube.com/watch?v=n0saIDd3H-M

	09.02.2023 (movie 17) Методы переноса.
К ним относятся Конструктор переноса (Move Constructor)
и Оператор присваивания переноса (Move Assignment).
	Методы переноса предназначены для того, чтобы создаваемые или существуюзий объект проинициализировать значением временного безымянного объекта.
Временный безымянный объект всякий раз не явно создается когда фенкция возвращает значение по значению, тогда возвращаемое значение копируется на место вызова и на месте вызова создается временный безымянный объект. Временные безымянные объекты сузествуют в пределах одного выраженияю.
Если возвращаемое значение фенкции является объектом, то для того, чтобы его скопировать на место вызова - вызывается конструктор копирования, а если этот объект использует динамическую память, то конструктор копрования еще и выполняет побитовое копирования (DeepCopy), что приводит к излишним затратам ресурсов памяти и процессорного времени. 
Все эти ресурсы затрачиваются на копирование объекта,который сразуже будет удален из памяти. И ресурсы, занимаемые этим локальным объектом будут освобождены. 
Для того, чтобы не копировать объект, который сейчас же будет удален, можно просто взять память, принадлежащую этому объекту и перенести ее на место вызова.
Эту фенкцию и выполняют Move-методы. В отличии от Copy-методов,  которые выполняют DeepCopy, Move-методы выполняют ShallowCopy. Т.е из одного объекта в другой копируют только указатель памяти, ьез выделения новой памяти. 
А скопировать 4 ил 8 байтовый указатель всегд абудет быстрее,чем скопировать масив с данными.
	Для локального объекта, перенесенного на место вызова вызлвется диструктор который очистит память, перенесенную на месот вызова. И для того, чтобы этого не произошло Move-методы кроме Shallow-Copy обязательно должны обнулять друго йобъект other). В противном случае, перенесенная память будет очищена. 
Move-Semantic впервые появилая в стандарте C++ 11. В C++ 03 были лишь Copy-методы.
Move-methods могут в значительной степени повысить производительность при спользовании динамической памяти.
Move-methods принимают не константную и не ссылку на объект, а R-value refference (ссылка на объект справа).

	String str1;			//Default constructor
	str1.print();
	String str2 = "Hello";	//Single Argument Constructor
	str2.print();
	String str3 = str2;		//CopyConstructor
	str3.print();
	String str4();			//Default constructor - На самом деле здесь не вызывается никакой конструктор, потому что здесь не создается объект.
							//Здесь создается функция str4(), которая не принимает ниаких параметров и возвразает значение типа String
	str4().print();         //- это не объект, это функция, а для функции нельзя вызвать метод.
	Если мы хотим явно вызвать конструктор по умолчанию, то это можно сделать так:
	String str5{};
  */